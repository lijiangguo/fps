# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Fantope Projection and Selection
#'
#' This function computes a solution path of the Fantope Projection and
#' Selection (FPS) estimator.  It takes a symmetric matrix \code{S} as input 
#' and returns an object containing a list of projection matrices 
#' estimated by FPS over a sequence of regularization parameter values.
#'
#' By default, a sensible minimum value of the regularization parameter 
#' is automatically chosen so that the minimally regularized solution
#' is different from PCA.
#'
#' @param S              Input matrix (assumed to be symmetric)
#' @param ndim           Target subspace dimension (can be fractional)
#' @param nsol           Number of solutions to compute
#' @param maxblocksize   Suggested maximum block size; ignored if \code{== 0}
#' @param lambdaminratio Minimum value of lambda as a fraction of 
#'                       the automatically determined maximum value of 
#'                       lambda; ignored if \code{< 0}
#' @param lambdamin      Minimum value of lambda; determined automatically if 
#'                       \code{< 0}
#' @param lambda         Vector of regularization parameter values; overrides //'                       nsol, maxblocksize, and lambdamin if nonempty
#' @param maxiter        Maximum number of iterations for each solution
#' @param tolerance      Convergence threshold
#' @param verbose        Level of verbosity; silent if \code{= 0}; otherwise 
#'                       display more messages and progress indicators as 
#'                       \code{verbose} increases
#'
#' @return An S3 object of class \code{fps} which is a list with the 
#'         following components:
#'   \item{ndim}{trace (dimension) of the estimate}
#'   \item{lambda}{a vector containing the regularization parameters of each 
#'                 estimate}
#'   \item{projection}{a list containing the the projection matrix estimates}
#'   \item{leverage}{a matrix whose columns are the diagonal entries of the 
#'                   projection matrix estimates}
#'   \item{L1}{a vector of the sum of absolute values of each estimate}
#'   \item{var.explained}{variance explained by each estimate (trace inner 
#'                        product of the projection and \code{S})}
#'   \item{var.total}{total variance (trace of \code{S})}
#'   \item{niter}{a vector containing the number of ADMM iterations for each 
#'                estimate}
#'
#' @details
#' For large input matrices (1000-by-1000 or larger) it is recommended 
#' that the \code{maxblocksize} argument be set to a reasonably small number.
#'
#' @export
#'
#' @examples
#' # Apply FPS to the standardized wine data from the UCI ML repository
#' data(wine)
#' out <- fps(cor(wine), ndim = 2)
#' print(out)
#' plot(out)
#'
#' # Create a synthetic dataset by adding noise variables to the wine data
#' j <- sample(1:ncol(wine), size = 500 - ncol(wine), replace = TRUE)
#' noise <- apply(wine[, j], 2, sample, replace = TRUE)
#' colnames(noise) <- rep('noise', ncol(noise))
#' x <- cbind(wine, noise)
#' out <- fps(cor(x), ndim = 2, maxblocksize = 50, verbose = 1)
#'
#' \dontrun{
#' # Choose lambda by cross-validation (this may take a few minutes)
#' cvout <- cv(out, x, FUN = cor, verbose = 1)
#' plot(cvout)
#' v <- coef(out, lambda = cvout$lambda.cv)
#' print(v)
#' }
#'
fps <- function(S, ndim, nsol = 50L, maxblocksize = 0L, lambdaminratio = -1, lambdamin = -1, lambda = as.numeric( c()), maxiter = 100L, tolerance = 1e-3, verbose = 0L) {
    .Call('fps_fps', PACKAGE = 'fps', S, ndim, nsol, maxblocksize, lambdaminratio, lambdamin, lambda, maxiter, tolerance, verbose)
}

#' Singular Value Projection and Selection
#'
#' This function computes a solution path of the Singular Value Projection 
#' and Selection (SVPS) estimator.  It takes a data matrix \code{x} as input 
#' and returns an object containing a list of projection matrices 
#' estimated by SVPS over a sequence of regularization parameter values.
#'
#' By default, a sensible minimum value of the regularization parameter 
#' is automatically chosen so that the minimally regularized solution
#' is different from the ordinary SVD.
#'
#' @param x              Input matrix
#' @param ndim           Target subspace dimension (can be fractional)
#' @param nsol           Number of solutions to compute
#' @param maxblocksize   Suggested maximum block size (rows + columns);
#'                       ignored if \code{== 0}
#' @param lambdaminratio Minimum value of lambda as a fraction of 
#'                       the automatically determined maximum value of 
#'                       lambda; ignored if \code{< 0}
#' @param lambdamin      Minimum value of lambda; automatically determined 
#'                       if \code{< 0}
#' @param lambda         Vector of regularization parameter values
#' @param maxiter        Maximum number of iterations for each solution
#' @param tolerance      Convergence threshold
#' @param verbose        Level of verbosity; silent if \code{= 0}; 
#'                       otherwise display more messages and progress 
#'                       indicators as \code{verbose} increases
#'
#' @details
#'
#' The default automatic choice of \code{lambdamin} ensures that the least 
#' regularized estimate omits at least one row or column. The solutions 
#' are automatically sorted in decreasing order of \code{lambda}.
#'
#' @return An S3 object of class \code{svps} which is a list with the 
#'         following components:
#'   \item{ndim}{Sum of squares (dimension) of the estimate}
#'   \item{lambda}{Vector containing the regularization parameters of each 
#'                 estimate.}
#'   \item{projection}{List containing the the (bi-)projection matrix 
#'                     estimates}
#'   \item{leverage.row}{Matrix whose columns are the row leverages}
#'   \item{leverage.col}{Matrix whose columns are the column leverages}
#'   \item{L1}{Vector of the sum of absolute values of each estimate}
#'   \item{var.row}{}
#'   \item{var.col}{}
#'   \item{var.total}{}
#'   \item{niter}{a vector containing the number of ADMM iterations for each 
#'                estimate}
#'
#' @export
#'
#' @examples
#' # Apply FPS to the standardized wine data from the UCI ML repository
#' data(wine)
#' out <- svps(scale(wine), ndim = 3)
#' print(out)
#' plot(out)
#'
svps <- function(x, ndim, nsol = 50L, maxblocksize = 0L, lambdaminratio = -1, lambdamin = -1, lambda = as.numeric( c()), maxiter = 100L, tolerance = 1e-3, verbose = 0L) {
    .Call('fps_svps', PACKAGE = 'fps', x, ndim, nsol, maxblocksize, lambdaminratio, lambdamin, lambda, maxiter, tolerance, verbose)
}

